/**
 * file@ spi_slave_driver.c
 *
 * @copyright 2015 by Sensus. All rights reserved.
 *
 *
 */


#include <stdbool.h>
#include <stdint.h>

#include "sys_int.h"
#include "prod_config.h"
#include "arch_device.h"
#include "arch_types.h"
#include "spi_slave_driver.h"
#include "spi_slave_phy.h"


typedef enum
{
   SpiSlave_Status_Released = 0,
   SpiSlave_Status_Initialized,
   SpiSlave_Status_Open,
   SpiSlave_Status_Closed,
} SpiSlave_Status_t;

SpiSlave_Status_t fSpiSlaveStatus[SpiSlave_NumberOfDevices] = { SpiSlave_Status_Released };

/**
 *
 *
 *
 *
 * @param deviceId
 */
Arch_DeviceResult_t SpiSlave_Init(SpiSlave_DeviceId_t deviceId)
{
   Arch_DeviceResult_t result = Arch_DeviceResult_NotImplemented;

   if (deviceId < SpiSlave_NumberOfDevices)
   {
      result = SpiSlave__PhyInit(deviceId);

      if (result == Arch_DeviceResult_Success)
      {
         fSpiSlaveStatus[deviceId] = SpiSlave_Status_Initialized;
      }
   }

   return(result);
}

/**
 *
 *
 *
 *
 * @param dHandlePtr
 * @param configPtr
 *
 * @return Arch_DeviceResult_t
 */
Arch_DeviceResult_t SpiSlave_Open(Arch_DeviceHandle_t *dHandlePtr, SpiSlave_Configuration_t *configPtr)
{
   Arch_DeviceResult_t result = Arch_DeviceResult_NotImplemented;
   SpiSlave_DeviceId_t device = configPtr->Interface;

   if (device < SpiSlave_NumberOfDevices)
   {
      if ((fSpiSlaveStatus[device] == SpiSlave_Status_Initialized) || (fSpiSlaveStatus[device] == SpiSlave_Status_Closed))
      {
         // The requested Interface is not presently being used
         // so we can open it and return back a Handle.
         result = SpiSlave__PhyOpen(configPtr);

         if(result == Arch_DeviceResult_Success)
         {
            fSpiSlaveStatus[device] = SpiSlave_Status_Open;
            *dHandlePtr = (Arch_DeviceHandle_t)device;
         }
      }
      else
      {
         // Device is already open so return back an error.
         result = Arch_DeviceResult_OutOfResources;
      }
   }

   return(result);
}

/**
 *
 *
 *
 *
 * @param dHandlePtr
 *
 * @return Arch_DeviceResult_t
 */
Arch_DeviceResult_t SpiSlave_Close(Arch_DeviceHandle_t *dHandlePtr)
{
   Arch_DeviceResult_t result = Arch_DeviceResult_NotImplemented;
   SpiSlave_DeviceId_t device = (SpiSlave_DeviceId_t)*dHandlePtr;

   if (device < SpiSlave_NumberOfDevices)
   {
      if (fSpiSlaveStatus[device] == SpiSlave_Status_Open)
      {
         result = SpiSlave__PhyClose(device);

         fSpiSlaveStatus[device] = SpiSlave_Status_Closed;
      }
      else
      {
         result = Arch_DeviceResult_NotOpen;
      }
   }
   else
   {
      result = Arch_DeviceResult_InvalidArgs;
   }

   *dHandlePtr = -1;

   return(result);
}

bool SpiSlave_IsDeepSleepAllowed()
{
   bool result = true;

   for (int device = 0; (device < SpiSlave_NumberOfDevices) && result; device++)
   {
      if (SpiSlave_Status_Open == fSpiSlaveStatus[device])
      {
         result = !SpiSlave__PhyIsActive(device);
      }
   }

   return result;
}

/**
 *
 *
 *
 *
 * @param deviceId
 */
Arch_DeviceResult_t SpiSlave_Release(SpiSlave_DeviceId_t deviceId)
{
   Arch_DeviceResult_t result = Arch_DeviceResult_NotImplemented;

   if (deviceId < SpiSlave_NumberOfDevices)
   {
      if (fSpiSlaveStatus[deviceId] == SpiSlave_Status_Open)
      {
         SpiSlave__PhyClose(deviceId);
      }
      SpiSlave__PhyRelease(deviceId);
      fSpiSlaveStatus[deviceId] = SpiSlave_Status_Released;
   }

   return(result);
}

/**
 *
 *
 *
 *
 * @param dHandlePtr
 *
 * @return Spi_ErrorCode_t
 */
SpiSlave_ErrorCode_t SpiSlave_ErrorCode(Arch_DeviceHandle_t *dHandlePtr)
{
   SpiSlave_ErrorCode_t result = SpiSlave_ErrorCode_None;

   return(result);
}

