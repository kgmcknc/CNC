/*
 * sim3l1xx_sys_timer.c
 *
 *
 */


#include <stdbool.h>

#include <sys_delay.h>

#include "efm32gg_sys_timer.h"

#include "efm32gg.h"
//#include "SI32_PMU_A_Type.h"
//#include "SI32_RTC_B_Type.h"

#include "arch_log.h"
#include "arch_system_time.h"


EFM32GG_SysTimerValue_t EFM32GG__SysTimerRead(void);

int                      EFM32GG__SysTimerSet(EFM32GG_SysTimerValue_t rtcCount);

EFM32GG_SysTimerCallbackFunction_t  fEFM32GG_SysTimerAlarmFunction[EFM32GG_UserAlarm2 + 1] =
{
   NULL, 
   NULL, 
   NULL  
};


/***********************************************************************************/
/*                                                                                 */
/***********************************************************************************/
void EFM32GG_SysTimerInit(bool powerUpInit)
{
   // ***********************************************************************
   //Setup the RTC
   // ***********************************************************************

   NVIC_DisableIRQ(RTC_IRQn);

   // Select clock for RTC clock source
   // SI32 used external XO
   //SI32_RTC_B_set_clock_source_rtc(SI32_RTC_0);
   // EFM32GG currently using LFRCO
   CMU->OSCENCMD = CMU_OSCENCMD_LFRCOEN; //Defaults to 32kHz

   CMU->LFCLKSEL |= CMU_LFCLKSEL_LFA_LFRCO;
   CMU->LFACLKEN0 |= CMU_LFACLKEN0_RTC;
   CMU->LFAPRESC0 |= CMU_LFAPRESC0_RTC_DIV1;

   //SI32_RTC_B_enable_crystal_oscillator(SI32_RTC_0);
   while(!(CMU->STATUS & _CMU_STATUS_LFRCORDY_MASK));

   //SI32_RTC_B_enable_rtc_timer(SI32_RTC_0);
   RTC->CTRL |= RTC_CTRL_EN;

   // At power up we need to set this value to 0.
   // If we are performing a RTC Reset then we need
   // to set it to the last known value.
   if (false == powerUpInit)
   {
#ifdef FLASHER_APPLICATION
      RTC->CNT = 0x000000;
      //SI32_RTC_B_write_setcap(SI32_RTC_0, 0x00000000);
#else
      uint32_t presentTime = (uint32_t) Arch_GetSystemTime();
      RTC->CNT = presentTime;
      //SI32_RTC_B_write_setcap(SI32_RTC_0, presentTime);
#endif
   }
   else
   {
      RTC->CNT = 0x000000;
   }

   if (true == powerUpInit)
   {
      // SI32 Had 3 Alarms associated with its RTC that
      // could be used to trigger interrupts.
      // RPH: EFM32GG only has 2 compare registers that
      // trigger RTC interrupts. Do we need the 3rd?
      // Should we use another timer to generate that
      // interrupt?

      RTC->COMP0 = 0xF00000;
      RTC->COMP1 = 0xF00000;

      RTC->IFC = RTC_IFC_COMP0;
      RTC->IFC = RTC_IFC_COMP1;

      NVIC_ClearPendingIRQ(RTC_IRQn);        // Clear Pending IRQ as part of the Init Routine
   }

   // ENABLE INTERRUPTS
   NVIC_EnableIRQ(RTC_IRQn);
}

/*****************************************************************************************************/
/*                                                                                                   */
/*****************************************************************************************************/
void RTC_IRQHandler(void)
{
   //SI32_PMU_A_clear_wakeup_flags(SI32_PMU_0);

//   NVIC_DisableIRQ(RTC0ALRM_IRQn);

   if (RTC->IF & RTC_IF_COMP0)
   {
      RTC->IFC = RTC_IFC_COMP0;
      
      if(fEFM32GG_SysTimerAlarmFunction[EFM32GG_UserAlarm0] != NULL)
      {
         if(false == ((*fEFM32GG_SysTimerAlarmFunction[EFM32GG_UserAlarm0])()))
         {

         }
      }
      else
      {
         RTC->IEN &= ~RTC_IEN_COMP0;
      }
   }

   if (RTC->IF & RTC_IF_COMP1)
   {
      RTC->IFC = RTC_IFC_COMP1;
      
      if(fEFM32GG_SysTimerAlarmFunction[EFM32GG_UserAlarm1] != NULL)
      {
         if(false == (*fEFM32GG_SysTimerAlarmFunction[EFM32GG_UserAlarm1])())
         {

         }
      }
      else
      {
         RTC->IEN &= ~RTC_IEN_COMP1;
      }
   }

#if 0
   if (SI32_RTC_B_is_alarm2_interrupt_pending(SI32_RTC_0))
   {
      SI32_RTC_B_clear_alarm2_interrupt(SI32_RTC_0);
      
      if(fSIM3L1XX_SysTimerAlarmFunction[SIM3L1XX_UserAlarm2] != NULL)
      {
         if(false == (*fSIM3L1XX_SysTimerAlarmFunction[SIM3L1XX_UserAlarm2])())
         {
            
         }
      }
      else
      {
         SI32_RTC_B_disable_alarm2_interrupt(SI32_RTC_0);
      }
   }
#endif
}

/*************************************************************************************************/
/*************************************************************************************************/
int EFM32GG__SysTimerSet(EFM32GG_SysTimerValue_t rtcCount)
{
   RTC->CNT = rtcCount;
   return 0;
}

EFM32GG_SysTimerValue_t EFM32GG__SysTimerRead(void)
{
   return RTC->CNT;
}

#if 0
void RTC0FAIL_IRQHandler(void)
{
   // If enabled we will get this interrupt if there is
   // a problem with the RTC clock.  The reason why we 
   // disable it in the interrupt is because if the 
   // interrupt is re enabled, we go right back in 
   // the interrupt if the clock is still bad.  We 
   // don't get a chance to fix it.

   SI32_RTC_B_clear_oscillator_fail_flag(SI32_RTC_0);

   NVIC_DisableIRQ(RTC0FAIL_IRQn);
}
#endif

void EFM32GG__SysTimerSetAlarm0(EFM32GG_SysTimerValue_t time)
{
   RTC->IEN |= RTC_IEN_COMP0_DEFAULT; // Disable COMP0 Interrupt
   RTC->IFC = RTC_IFC_COMP0;          // Clear Interrupt Flag
   RTC->COMP0 = time;                 // Set Next Interrupt Time
   RTC->IEN |= RTC_IEN_COMP0;         // Enable COMP0 Interrupt
}

EFM32GG_SysTimerValue_t EFM32GG__SysTimerReadAlarm0(void)
{
   return(RTC->COMP0);
}


void EFM32GG__SysTimerDisableAlarm0(void)
{
   RTC->IEN |= RTC_IEN_COMP0_DEFAULT; // Disable COMP0 Interrupt
   RTC->IFC = RTC_IFC_COMP0;          // Clear Interrupt Flag
}


void EFM32GG__SysTimerSetAlarm1(EFM32GG_SysTimerValue_t time)
{
   RTC->IEN |= RTC_IEN_COMP1_DEFAULT; // Disable COMP1 Interrupt
   RTC->IFC = RTC_IFC_COMP1;          // Clear Interrupt Flag
   RTC->COMP1 = time;                 // Set Next Interrupt Time
   RTC->IEN |= RTC_IEN_COMP1;         // Enable COMP1 Interrupt
}

EFM32GG_SysTimerValue_t EFM32GG__SysTimerReadAlarm1(void)
{
   return(RTC->COMP1);
}

void EFM32GG__SysTimerDisableAlarm1(void)
{
   RTC->IEN |= RTC_IEN_COMP1_DEFAULT; // Disable COMP1 Interrupt
   RTC->IFC = RTC_IFC_COMP1;          // Clear Interrupt Flag
}

#if 0
void SIM3L1XX__SysTimerSetAlarm2(SIM3L1XX_SysTimerValue_t time)
{
   SI32_RTC_B_disable_alarm2_interrupt(SI32_RTC_0);
   SI32_RTC_B_clear_alarm2_interrupt(SI32_RTC_0);
   SI32_RTC_B_write_alarm2(SI32_RTC_0, time);
   SI32_RTC_B_enable_alarm2_interrupt(SI32_RTC_0);
}

SIM3L1XX_SysTimerValue_t SIM3L1XX__SysTimerReadAlarm2(void)
{
   return(SI32_RTC_B_read_alarm2(SI32_RTC_0));
}

void SIM3L1XX__SysTimerDisableAlarm2(void)
{
   SI32_RTC_B_disable_alarm2_interrupt(SI32_RTC_0);
   SI32_RTC_B_clear_alarm2_interrupt(SI32_RTC_0);
}
#endif

bool EFM32GG_SysTimerRegisterCompareCallBackFunction(EFM32GG_UserAlarm_t alarm, EFM32GG_SysTimerCallbackFunction_t CallBackFunctionPtr)
{
   bool result = false;

   if (alarm < EFM32GG_UserAlarm2)
   {
      if (CallBackFunctionPtr != NULL)
      {
         fEFM32GG_SysTimerAlarmFunction[alarm] = CallBackFunctionPtr;
         result = true;
      }
   }
   return(result);
}





